<div><div><p><span style="font-family: verdana;">KDU stands for Kernel Driver Utility. It was developed mainly to assist in some other projects, like for example <a href="https://swapcontext.blogspot.com/2020/02/vboxhardenedloader-v2.html">VBoxHardenedLoader</a>. Since release in the beginning of 2020 it supported various vulnerable drivers as "functionality providers".</span></p><p><span style="font-family: verdana;">Overall these are the major 1.1 version changes:</span></p><ul style="text-align: left;"><li><span style="font-family: verdana;">Driver mapping shellcode has been updated, two additional shellcode variants have been added;</span></li><li><span style="font-family: verdana;">More vulnerable drivers from Huawei, Realtek, MSI, LG, ASUSTeK have been added.</span></li></ul></div><p><span style="font-family: verdana;"></span></p><p><span style="font-family: verdana;">Details about changes are below.<br /></span></p><h3 style="text-align: left;"><span style="font-family: verdana;">Shellcode variants<br /></span></h3><p><span style="font-family: verdana;">Overall shellcode has been redesigned to work with mapped section instead of registry. Previous version read payload driver image from Windows registry specific key. It was quick and cheap solution as I didn't bother with it and just re-used Stryker bootstrap shellcode variant. Now KDU will allocate special section with random name to store payload driver image, <i>additional parameters</i> and to query result uppon shellcode execution completion.</span></p><p><span style="font-family: verdana;">There are three variants of driver mapping shellcode available for selection via <b><i>-scv &lt;number&gt;</i></b> command. The difference between them is how they handle payload execution part. First variant uses newly created system thread to run payload entry point. It is pretty much the same method as original KDU/TDL/Stryker use. Second allocates work item and runs payload entry point within existing system worker thread. Third is more complex as it is designed for a small limited usage with drivers that are unaware of preconditions required for manual mapping. Preciously they require their <b><i>DriverEntry</i></b> parameters to be valid. This shellcode variant will allocate driver object, fill it common part and pass it together with supplied registry path to the payload <b><i>DriverEntry</i></b> as parameters. This is something like <i>Dustman</i> copy-pasters did with <i>Eldos RawDisk</i> however it also provides <u>valid</u> registry path parameter which is can be used by payload driver. While using 3rd shellcode version you need to supply driver object name using command <b><i>-drvn &lt;ObjectName&gt;</i></b> and optionally registry key name <b><i>-drvr &lt;RegName&gt;</i></b>. If no registry key name specified KDU will assume registry key name is the same as driver object name. Examples of usage -&gt; <a href="https://github.com/hfiref0x/KDU#usage">https://github.com/hfiref0x/KDU#usage</a>.</span></p><h3 style="text-align: left;"><span style="font-family: verdana;">New providers<br /></span></h3><ul style="text-align: left;"><li><span style="font-family: verdana;">Huawei PhyMemx64 driver from Huawei MateBook Manager of various versions. This driver is a blatant copy-paste from infamous WINIO source code;</span></li><li><span style="font-family: verdana;">Realtek RtkIo64 driver from Realtek Dash Client Utility of various versions. This driver based on PHYMEM open-source project code, which is a wormhole by design;</span></li><li><span style="font-family: verdana;">EneTechIo64 from MSI Dragon Center, it is similar to previously added EneTech variants (all based on WINIO), however it utilizes "unique" unlocking algorithm (see <a href="https://swapcontext.blogspot.com/2020/08/ene-technology-inc-vulnerable-drivers.html">https://swapcontext.blogspot.com/2020/08/ene-technology-inc-vulnerable-drivers.html</a> for a complete overview) and freshly signed so that is why I decided to add this variant too;</span></li><li><span style="font-family: verdana;">LG LHA driver from LG Device Manager, which is explained in Jackson_T <a href="http://www.jackson-t.ca/lg-driver-lpe.html">blogpost</a>. This driver is semi-original with some influence of open-source projects;</span></li><li><span style="font-family: verdana;">ASUSTeK AsIO2 driver from ASUS GPU Tweak utility, this driver also described in my blogpost about EneTech drivers derivatives.</span></li></ul></div><span style="font-family: verdana;">That's all about KDU. Ironically bonus part is much longer.<br /></span><div><p></p><p></p><p></p><h3 style="text-align: left;"><span style="font-family: verdana;">Bonus (AsIO3.sys unlock)<br /></span></h3><p><span style="font-family: verdana;">ASUSTeK "giveio" drivers seems had some special love from the developers who are sitting on WINIO source code in EneTech. GLCKIO, GLCKIO2, AsIO, AsIo&lt;O&gt;&lt;variousnames&gt;, AsIO2 and now AsIO3. What they share in common (except WINIO base) - their authors never fix their bugs. They actually just pull "new" version of driver when someone find a bug in it and contact ASUS for security reasons. Numerous CVE numbers generated by various groups/researches etc. So what they actually changing? Well, they just switching driver "locks" - a primitive handmade solutions which purpose is to block usage of the given driver by 3rd party. And under 3rd party I mean - block and/or ruin the way this driver was exploited in the submitted security issue. Thus submitted issue will be no longer reproducible as-is and they can tell - hey we fixed it, now you can gtfo, lol. Sometimes, like in case of AsIO2 their newly added locking code adds additional bugs and vulnerabilities. But nobody cares I guess.<br /></span></p><p><span style="font-family: verdana;">Their latest release is AsIO3.sys with self-explaining pdb (</span><span style="font-family: verdana;"><i><b><span class="css-901oao css-16my406 r-poiln3 r-bcqeeo r-qvutc0">C:\Working\MB\GLCKIO2\AsIO3\x64\Release\AsIO3_64.pdb</span></b></i>). The key changes compared to AsIO2:</span></p><ol style="text-align: left;"><li><span style="font-family: verdana;">They have been forced to make it pass Driver Verifier checks; ??</span></li><li><span style="font-family: verdana;">New driver lock, no more TinyAES with keys found by devs in Google search;</span></li><li><span style="font-family: verdana;">All the bugs/vulnerabilities of WINIO stay same.<br /></span></li></ol><p><span style="font-family: verdana;">Driver is fresh and comes as part of <b>ASUS GPU Tweak software v2303</b>.</span></p><p></p><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto;"><tbody><tr><td style="text-align: center;"><a href="https://1.bp.blogspot.com/-Zfonmy4A1F4/YIEyoLF-voI/AAAAAAAAAX8/bO4qikNIP3YG35LSafGK39Vdi_KJytuCACLcBGAsYHQ/s478/AsIo3.png" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="478" data-original-width="405" src="https://1.bp.blogspot.com/-Zfonmy4A1F4/YIEyoLF-voI/AAAAAAAAAX8/bO4qikNIP3YG35LSafGK39Vdi_KJytuCACLcBGAsYHQ/s16000/AsIo3.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Pic 1. AsIO3 details.<br /></td></tr></tbody></table><p><br /><span style="font-family: verdana;">New driver "lock" looks pretty damn solid and complicated! I mean they wasted so much code to create this ineffective piece of garbage while instead they could put their efforts into fixing (or even rewriting) entire WINIO instead. To "unlock" previous AsIO2 all you need - generate special resource named "asuscert" and put it into your application resources, see complete unlocking code <a href="https://gist.github.com/hfiref0x/585e22bc50f07c4baf0d5f6b7fcba0f9">here</a>. In newest versions everything changed.&nbsp;</span></p><p><span style="font-family: verdana;">AsIO contain three components - <b><i>AsusCertService.exe (32bit)</i></b>, wrapper dll and driver. In the AsIO3 driver implemented special check of requestor application during <i>IRP_MJ_CREATE</i>. Driver reads file from disk, calculates SHA256 for it and compares this value with hardcoded hash. If they do not match - <i>STATUS_ACCESS_DENIED</i> will be returned to the caller.</span></p><p></p><p></p><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto;"><tbody><tr><td style="text-align: center;"><a href="https://1.bp.blogspot.com/-jdAYUvl2lKs/YIE2QYm7p7I/AAAAAAAAAYE/M6hORHADrSA40mmU4XYa7VBXLR5jW6sagCLcBGAsYHQ/s474/hash.png" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="37" data-original-width="474" src="https://1.bp.blogspot.com/-jdAYUvl2lKs/YIE2QYm7p7I/AAAAAAAAAYE/M6hORHADrSA40mmU4XYa7VBXLR5jW6sagCLcBGAsYHQ/s16000/hash.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Pic 2. AsusCertService.exe SHA256 hardcoded in AsIO3 driver<br /></td></tr></tbody></table><p><br /><span style="font-family: verdana;">Thus initially only AsusCertService.exe allowed to open and communicate with AsIO3 driver. Entire purpose of this executable is to manage connections for AsIO3 driver. This driver also provides a way to register "trusted application" that will be able to call AsIO3. AsusCertService setups named pipe (no SD set ROFL) called "asuscert". Now if another application want to use AsIO3 and should contact AsusCertService via named pipe. AsusCertService will validate client executable to be digitally signed and signer must be one of the hardcoded values as shown below.<br /></span></p><p></p><p><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto;"><tbody><tr><td style="text-align: center;"><a href="https://1.bp.blogspot.com/-J-rFwU9MotA/YIE6_bEHbeI/AAAAAAAAAYM/YgM5UxAgFfI1f5omdSpZ9Q9SLlRdmY3PQCLcBGAsYHQ/s853/AsIo3_Nx.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="391" data-original-width="853" src="https://1.bp.blogspot.com/-J-rFwU9MotA/YIE6_bEHbeI/AAAAAAAAAYM/YgM5UxAgFfI1f5omdSpZ9Q9SLlRdmY3PQCLcBGAsYHQ/s16000/AsIo3_Nx.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Pic 3. AsusCertService client signer check.<br /></td></tr></tbody></table><span style="font-family: verdana;"></span></p><p><span style="font-family: verdana;">After successful check service will register client process as trusted for AsIO3 driver by sending special IOCTL <b>0xA040A490</b> with input buffer set to client process id. Driver manage this list similar to GLCKIO2 where it was firstly introduced. Another IOCTL <b>0xA040A494</b> used to remove client process id from trusted process list.</span><span style="font-family: verdana;">&nbsp;</span></p><p><span style="font-family: verdana;">How to bypass this garbage and completely useless code and unlock this driver for your application:</span></p><ol style="text-align: left;"><li><span style="font-family: verdana;">Make a copy of AsusCertService somewhere, make sure it is unmodified otherwise driver side hash check will fail;</span></li><li><span style="font-family: verdana;">Create a zombie process from this copy, stop before calling entrypoint;</span></li><li><span style="font-family: verdana;">Unmap original code and replace it with your own shellcode;</span></li><li><span style="font-family: verdana;">Resume zombie process;</span></li><li><span style="font-family: verdana;">In a shellcode -&gt; open driver and register your parent process in trusted process list using </span><span style="font-family: verdana;"><span style="font-family: verdana;"><b>0xA040A490</b> </span> IOCTL code;</span></li><li><span style="font-family: verdana;">Make sure AsusCertService zombie process will be alive and kicking (put it into infinite wait for example in your shellcode) while your main process is working, this is to prevent AsIO3 driver from zeroing trusted processes list; <br /></span></li><li><span style="font-family: verdana;">Now from your process you can do whatever you want with AsIO3, for example BSOD it (since AsIO3 provides full set of unfixed WINIO vulnerabilities/bugs). <br /></span></li></ol><p></p><p></p><p><span style="font-family: verdana;"></span></p><p></p><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-MvI3Irj4j9U/YIFCHt49kLI/AAAAAAAAAYg/5HIKdEMhoD86WWQ6WazeiynPcSoVse4GgCLcBGAsYHQ/s760/bsod0.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="205" data-original-width="760" src="https://1.bp.blogspot.com/-MvI3Irj4j9U/YIFCHt49kLI/AAAAAAAAAYg/5HIKdEMhoD86WWQ6WazeiynPcSoVse4GgCLcBGAsYHQ/s16000/bsod0.png" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-hsrAOH1oib0/YIFCHpVmK_I/AAAAAAAAAYc/X7KxkCCK45sj562-PiEWw6o_f3_b1-0xQCLcBGAsYHQ/s1130/bsod1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="476" data-original-width="1130" src="https://1.bp.blogspot.com/-hsrAOH1oib0/YIFCHpVmK_I/AAAAAAAAAYc/X7KxkCCK45sj562-PiEWw6o_f3_b1-0xQCLcBGAsYHQ/s16000/bsod1.png" /></a></div><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto;"><tbody><tr><td style="text-align: center;"><a href="https://1.bp.blogspot.com/-RmkSIUT5DVA/YIFCKn5M2_I/AAAAAAAAAYk/PoH_ofb8aUcbyMx2zA4N17U3xaHlmkAYQCLcBGAsYHQ/s1024/AsIo3_BSOD.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="768" data-original-width="1024" height="480" src="https://1.bp.blogspot.com/-RmkSIUT5DVA/YIFCKn5M2_I/AAAAAAAAAYk/PoH_ofb8aUcbyMx2zA4N17U3xaHlmkAYQCLcBGAsYHQ/w640-h480/AsIo3_BSOD.png" width="640" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Pic 4. AsIO3 usual state.<br /></td></tr></tbody></table><span style="font-family: verdana;"></span><p></p><p><span style="font-family: verdana;">Well, what can I say.</span><span style="font-family: verdana;"> A quantum supercomputer calculating for a thousand years could not even approach the number of fucks which ASUS do not give when it comes to security of their drivers.</span></p><p><span style="font-family: verdana;">AsIO3 unlock PoC can be found at -&gt; <a href="https://github.com/hfiref0x/AsIo3Unlock">https://github.com/hfiref0x/AsIo3Unlock</a><br /></span></p><h3 style="text-align: left;"><span style="font-family: verdana;">Disclaimer</span></h3><p><span style="font-family: verdana;">Using KDU program might crash your computer with BSOD. Compiled binary
 and source code provided AS-IS in hope it will be useful BUT WITHOUT 
WARRANTY OF ANY KIND. Since KDU rely on completely bugged and vulnerable drivers security of computer where it executed maybe put at risk. Make sure you understand what you do.<br /></span></p><div><p><span style="font-family: verdana;">KDU github with precompiled binaries -&gt; <a href="https://github.com/hfiref0x/KDU">https://github.com/hfiref0x/KDU</a><br /></span></p></div></div>