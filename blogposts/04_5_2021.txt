<p><span style="font-family: verdana;"></span></p><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto;"><tbody><tr><td style="text-align: center;"><a href="https://1.bp.blogspot.com/-GgbFN7CD-ys/YGrQN6_6LQI/AAAAAAAAAXo/aKUF4i0FkXMUbVueVrpeJ1XEQG5ZKIKqwCLcBGAsYHQ/s740/Trend-Micro-RootkitBuster.jpg" style="margin-left: auto; margin-right: auto;"><img border="0" data-original-height="490" data-original-width="740" src="https://1.bp.blogspot.com/-GgbFN7CD-ys/YGrQN6_6LQI/AAAAAAAAAXo/aKUF4i0FkXMUbVueVrpeJ1XEQG5ZKIKqwCLcBGAsYHQ/s16000/Trend-Micro-RootkitBuster.jpg" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Pic 1. TrendMicro abandonware.<br /></td></tr></tbody></table><span style="font-family: verdana;">&nbsp;</span><p></p><p><span style="font-family: verdana;">Recently I came across an article <a href="https://billdemirkapi.me/how-to-use-trend-micros-rootkit-remover-to-install-a-rootkit/">"How to use Trend Micro’s Rootkit Remover to Install a Rootkit"</a> by Bill Demirkapi. It covers TrendMicro out of date antirootkit called "RootkitBuster". TL;DR it is dangerous software full of hacks and potential kernel level vulnerabilities. </span><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>My interest was attracted by the part</span></span></span>  about some pieces of code author of blogpost found weird. After reading it I thought that I can actually answer on questions made in this blogpost.</span> <span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="ru" data-phrase-index="0"><span>A little introduction and small </span></span></span></span><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="ru" data-phrase-index="0"><span><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="ru" data-phrase-index="0"><span>excursion into history</span></span></span> are required before we can move on to answering questions. <br /></span></span></span></span></p><h3 style="text-align: left;"><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="ru" data-phrase-index="0"><span>Long time ago in a galaxy far away <br /></span></span></span></span></h3><p><span style="font-family: verdana;"></span></p><p><span style="font-family: verdana;">I'm familiar with this software since... hmm decades? It just so happened that I probably know one of the guys who worked on this software and in general familiar with this software class, it design and reasons why it looks so terrible from this year perspective.</span></p><p><span style="font-family: verdana;">Rootkit Buster is a classic 3rd generation antirootkit created in the second half of the </span><span style="font-family: verdana;"><span face="&quot;verdana&quot; , sans-serif"><span style="font-weight: normal;">200x in response to dominance of kernel mode rootkits on MS Windows. Almost every ISV created this kind of software in that times, some made standalone tools like TrendMicro, Kaspersky, Avast, BitDefender, Sophos, F-Secure (with their infamous by it uselessness BlackLight). Some ISV incorporated their functionality directly into their mainstream products like for example Dr.Web or later Avast (when they acquired author of freeware GMER).</span></span> Almost all of them were useless and never bothered rootkit developers to address their detection's in rootkit updates. There is a few exceptions of course like Dr.Web antirootkit engine and Kaspersky TDSSKiller. Aside of this anything else were merely a jokes. Entire battlefront with rootkits of that era was up to freeware tools made by enthusiasts. Starting from Rutkowska PoC's (like system virginity verifier, klister) and following 2nd generation with IceSword from pjf, Darkspy from CardMagic and wowocock and ending up 3rd generation with various tools like KDetective, RootRepeal, GMER many many of them (I have complete museum collection of them, including various versions, which is about 200 mb archive).</span></p><p><span style="font-family: verdana;">While notorious malware families of that time largely utilized kernel mode rootkit components it were developed by a really small group of original authors. It was obvious for everyone who were familiar with their design and implementation (winking for those I know). Later in the beginning of 201x they left and market was flooded with copy-pasted, "renewed" junk copies. It quickly degenerated completely and moved into limited usage in the APT, like for example Turla rootkit which is heavily inspired by 200x solutions for antidetection.</span></p><h4 style="text-align: left;"><span style="font-family: verdana;">Really, really bad code?</span></h4><p><span style="font-family: verdana;">Both rootkits/antirootkits were using completely undocumented stuff, internal Windows structures, doing with kernel basically all what they want in a <u>completely unsafe manner</u>. Was it bad code? Obviously, for reference you can look on KSBinSword - a Chinese IceSword copy-paste clone with <a href="https://github.com/gerronjo/openlibs/tree/master/KsBinSword">source code</a> available. Solutions it used were widely used in any other antirootkits of that times. Or look on more recent Kernel Detective with also now available <a href="https://github.com/Fyyre/kerneldetective">source code</a>. Unfortunately there was no way to successfully counteract malware rootkits without going on their or deeper level. Which required going deeper into undocumented thing and unsafe solutions. So was it really "bad" code? BSOD-generators for sure. Have you ever saw Kaspersky AV 6.0-7.0 source code? It is a ridiculous mess and their drivers are dangerous bugfest by design. Does it mean Kaspesrky 6/7 were failures? Nope, they both were highly successful and actually delivered a lot of problems for malware authors of that time. It was bad but it was adequate solution to that time. Simple because everything else was ineffective. This mess required operation system vendor response at first place. And MS did the job so now </span><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>we can look into the past and be horrified.</span></span></span></span></p><p><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>Rootkit Buster is a direct successor of those times (it both design and code) and has been really polished compared to most of other ISV tools of this kind. This does not mean it is highly effective against dedicated malware it only mean that others are can be worse.</span></span></span></span></p><h4 style="text-align: left;"><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>Bruteforcing Processes<br /></span></span></span></span></h4><p><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>What is the point of it and why not use documented API here, as blogpost author stated? It is a simple answer if you somewhat familiar with rootkit/antirootkit development.&nbsp;</span></span></span></span></p><p><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>Usually we use the <b><i>ZwQuerySystemInformation </i></b>function in the kernel to 
traverse the process module and obtain the process information. This is 
through the normal process traversal method. Therefore, multiple rootkits will intercept the <b><i>ZwQuerySystemInformation</i></b> function to filter the 
specified process to realize the hidden process. </span></span></span></span><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>At the time, you couldn't trust</span></span></span> in regular API call result because they can be easily faked through DKOM or manipulations with API hooks on various levels. Trust no one except yourself - is a main slogan for antirootkits of that era. One of the first tools implemented PID bruteforce for detecting hidden processes was, suprise-surprise, F-Secure Blacklight. There is nothing wrong with this method, </span></span></span></span><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>it quickly became outdated</span></span></span>  as rootkits managed to go deeper and </span></span></span></span><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>started modifying kernel objects</span></span></span>  structures, however it still has right to exist. Of course all this apply to 200x era.</span></span></span></span></p><h4 style="text-align: left;"><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>Bruteforcing Offsets</span></span></span></span></h4><p><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>Why not use <b><i>ZwQueryInformatonProcess</i></b> with ProcessImageFileName here?</span></span></span></span></p><p><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>Again if you familiar with things answer is simple. </span></span></span></span><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>Using API in that case will ultimately lead into malicious hook where returned data will be faked. Aside from t</span></span></span></span>his it is not an Rootkit Buster innovation - in fact they simple used same code snipped with known for ages Russinovich RegMon source code (or maybe even earlier). In an effort to remain version-independent, rather than using a hard-coded offsets, it scan the process object structure memory looking for the name, which should match that of the GUI process, see RegMon <a href="https://github.com/weixu8/RegMon/blob/master/DD/REGSYS.C#L1542">source code</a>. <br /></span></span></span></span></p><h4 style="text-align: left;"><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>EPROCESS PEB Offset</span></span></span></span></h4><p><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>Same as above. You can't trust API here unless you want to jump into rootkit trap. Notorious hardcore rootkits of that era always played at the edge of system collapse, modifying anything until the limit where they can't keep system alive anymore. Besides, offset are required to direct access to the kernel structures (thus avoiding all API hooks). Process Environment Block location is one of the key things for every antirootkit.<br /></span></span></span></span></p><h4 style="text-align: left;"><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>ETHREAD StartAddress Offset</span></span></span></span></h4><p><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>Same as above. This offset needed for direct access to the object structure field. Additionally such scans are somewhat version independent code thus you don't need to hardcode 10-15 versions of ETHREAD offsets for single structure member if you have to support multiple Windows versions. None of API calls here (<b><i>ZwQueryInformationThread</i></b>) does makes any sense. </span></span></span></span><br /></p><p><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>Pretty
 much all of the questions author made can be answered by just taking a 
look in any of "Rootkits blah blah blah" books dated back to 200x.</span></span></span></span></span></span></span></span></p><h4 style="text-align: left;"><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>So Why?</span></span></span></span></h4><p><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>RootkitBuster is a combination of out-dated techniques, methods from Windows XP era, that (it is my guess) are just blatantly copied from x86-32 and compiled for x64 without any actual refactoring (except part for making it compilable and verifier friendly ROFL). Obviously parts of code highlighted by author has a little sense (if any) on 64 bit Windows version with PatchGuard and other fancy security features built-in. In general this software has no sense on x64 and looks completely abandoned. It version 5 was released in 2011, do you see any hints here?</span></span></span></span></p><p><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>Just reversing of drivers for exploits is not enough for their code complete understanding. You have to be familiar with what they actually do and how this is implemented, not to say about </span></span></span></span><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>baggage of experience in that field.</span></span></span> </span></span></span></span></p><p><span style="font-family: verdana;"><span class="VIiyi" lang="en"><span class="JLqJ4b ChMk0b" data-language-for-alternatives="en" data-language-to-translate-into="auto" data-phrase-index="0"><span>From a malicious usage perspective RootkitBuster also has nothing to offer. Take it as a sort of unusual museum exponent. If you want to look at really dangerous software actively developed and distributed under multiple "best security</span></span></span>" crapware brands - take Zemana (or any of it pseudonyms) driver as example of complete hack-o-rama, right here, right now on x64.<br /></span></p>